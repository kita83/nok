use crate::migration::{
    MigrationManager, MigrationResult,
    legacy::LegacyDataLoader,
    converter::IdMappings,
    config::ConfigMigrator,
};
use crate::matrix::{MatrixClient, MatrixConfig};

/// Migration command executor
pub struct MigrationCommand {
    legacy_db_path: String,
    server_name: String,
}

impl MigrationCommand {
    /// Create a new migration command
    pub fn new(legacy_db_path: impl Into<String>, server_name: impl Into<String>) -> Self {
        Self {
            legacy_db_path: legacy_db_path.into(),
            server_name: server_name.into(),
        }
    }

    /// Execute the complete migration process
    pub async fn execute(&self) -> Result<MigrationResult, Box<dyn std::error::Error>> {
        println!("🚀 Starting nok → Matrix migration...");
        println!("=====================================");

        // Step 1: Load and analyze legacy data
        println!("\n📖 Step 1: Loading legacy data...");
        let loader = LegacyDataLoader::new(&self.legacy_db_path);
        let legacy_data = loader.load_all().await?;

        // Step 2: Generate ID mappings
        println!("\n🔄 Step 2: Generating Matrix ID mappings...");
        let mappings = IdMappings::generate_from_legacy_data(
            &legacy_data.users,
            &legacy_data.rooms,
            &self.server_name
        );

        // Save mappings for reference
        let mappings_file = format!("migration_mappings_{}.json", chrono::Utc::now().timestamp());
        mappings.save_to_file(&mappings_file)?;

        // Step 3: Configure Matrix client
        println!("\n🔧 Step 3: Setting up Matrix client...");
        let matrix_config = MatrixConfig {
            homeserver_url: format!("http://{}:6167", self.server_name),
            server_name: self.server_name.clone(),
            state_store_path: "migration_matrix_state.db".to_string(),
        };

        let matrix_client = MatrixClient::new(matrix_config).await?;

        // Step 4: Create migration manager and execute
        println!("\n🏗️  Step 4: Executing data migration...");
        let mut migration_manager = MigrationManager::new(
            matrix_client,
            &self.legacy_db_path
        );

        // Create backups first
        migration_manager.backup_legacy_config()?;

        // Execute migration
        let result = migration_manager.migrate().await?;

        // Step 5: Migrate configuration files
        println!("\n⚙️  Step 5: Migrating configuration...");
        let config_migrator = ConfigMigrator::new()?;

        // Use the first user as default for config migration
        if let Some(first_user) = legacy_data.users.first() {
            if let Some(matrix_user_id) = mappings.get_matrix_user_id(&first_user.id) {
                config_migrator.migrate_config(matrix_user_id)?;
            }
        }

        // Step 6: Generate migration report
        println!("\n📊 Step 6: Generating migration report...");
        self.generate_migration_report(&result, &legacy_data, &mappings)?;

        println!("\n✅ Migration completed successfully!");
        println!("=====================================");

        Ok(result)
    }

    /// Generate a detailed migration report
    fn generate_migration_report(
        &self,
        result: &MigrationResult,
        legacy_data: &crate::migration::legacy::LegacyData,
        mappings: &IdMappings,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let report_content = format!(
            r#"# nok → Matrix Migration Report

## Migration Summary
- **Date**: {}
- **Legacy Database**: {}
- **Target Server**: {}

## Migration Results
- **Users Migrated**: {} / {}
- **Rooms Migrated**: {} / {}
- **Messages Processed**: {} / {}
- **Errors**: {}

## ID Mappings

### Users
{}

### Rooms
{}

## Legacy Data Overview
- **Total Users**: {}
- **Total Rooms**: {}
- **Total Messages**: {}
- **Room Memberships**: {}

## Next Steps
1. Create Matrix accounts for migrated users
2. Set up Matrix rooms with appropriate permissions
3. Invite users to their respective rooms
4. Test Matrix functionality with new IDs
5. Update client configurations to use Matrix settings

## Files Generated
- ID Mappings: migration_mappings_*.json
- Matrix Config: ~/.config/nok/matrix_config.json
- Database Backup: {}.backup.*
- Config Backup: ~/.config/nok/config.json.backup.*

---
Generated by nok migration tool
"#,
            chrono::Utc::now().format("%Y-%m-%d %H:%M:%S UTC"),
            self.legacy_db_path,
            self.server_name,
            result.users_migrated,
            legacy_data.users.len(),
            result.rooms_migrated,
            legacy_data.rooms.len(),
            result.messages_migrated,
            legacy_data.messages.len(),
            result.errors.len(),
            self.format_user_mappings(legacy_data, mappings),
            self.format_room_mappings(legacy_data, mappings),
            legacy_data.users.len(),
            legacy_data.rooms.len(),
            legacy_data.messages.len(),
            legacy_data.room_memberships.len(),
            self.legacy_db_path,
        );

        let report_filename = format!("migration_report_{}.md", chrono::Utc::now().timestamp());
        std::fs::write(&report_filename, report_content)?;

        println!("📝 Migration report saved to: {}", report_filename);
        Ok(())
    }

    /// Format user mappings for report
    fn format_user_mappings(
        &self,
        legacy_data: &crate::migration::legacy::LegacyData,
        mappings: &IdMappings,
    ) -> String {
        let mut output = String::new();
        for (legacy_id, matrix_id) in &mappings.user_mappings {
            if let Some(user) = legacy_data.users.iter().find(|u| u.id == *legacy_id) {
                output.push_str(&format!("- `{}` → `{}`\n", user.name, matrix_id));
            }
        }
        output
    }

    /// Format room mappings for report
    fn format_room_mappings(
        &self,
        legacy_data: &crate::migration::legacy::LegacyData,
        mappings: &IdMappings,
    ) -> String {
        let mut output = String::new();
        for (legacy_id, matrix_id) in &mappings.room_mappings {
            if let Some(room) = legacy_data.rooms.iter().find(|r| r.id == *legacy_id) {
                if let Some(alias) = mappings.get_matrix_room_alias(legacy_id) {
                    output.push_str(&format!("- `{}` → `{}` (#{alias}:{})\n", room.name, matrix_id, self.server_name));
                }
            }
        }
        output
    }

    /// Dry run migration (analysis only)
    pub async fn dry_run(&self) -> Result<(), Box<dyn std::error::Error>> {
        println!("🔍 Migration Dry Run Analysis");
        println!("=============================");

        // Load legacy data
        println!("\n📖 Loading legacy data...");
        let loader = LegacyDataLoader::new(&self.legacy_db_path);
        let legacy_data = loader.load_all().await?;

        // Generate ID mappings
        println!("\n🔄 Generating ID mappings...");
        let mappings = IdMappings::generate_from_legacy_data(
            &legacy_data.users,
            &legacy_data.rooms,
            &self.server_name
        );

        // Analysis
        println!("\n📊 Migration Analysis:");
        println!("  Users to migrate: {}", legacy_data.users.len());
        println!("  Rooms to migrate: {}", legacy_data.rooms.len());
        println!("  Messages to process: {}", legacy_data.messages.len());
        println!("  Room memberships: {}", legacy_data.room_memberships.len());

        println!("\n🆔 Sample ID Mappings:");
        for (i, (legacy_id, matrix_id)) in mappings.user_mappings.iter().enumerate().take(3) {
            if let Some(user) = legacy_data.users.iter().find(|u| u.id == *legacy_id) {
                println!("  User: {} → {}", user.name, matrix_id);
            }
            if i >= 2 { break; }
        }

        for (i, (legacy_id, matrix_id)) in mappings.room_mappings.iter().enumerate().take(3) {
            if let Some(room) = legacy_data.rooms.iter().find(|r| r.id == *legacy_id) {
                if let Some(alias) = mappings.get_matrix_room_alias(legacy_id) {
                    println!("  Room: {} → {} (#{alias}:{})", room.name, matrix_id, self.server_name);
                }
            }
            if i >= 2 { break; }
        }

        // Check for potential issues
        println!("\n⚠️  Potential Issues:");
        let mut issues = Vec::new();

        // Check for non-ASCII room names
        for room in &legacy_data.rooms {
            if !room.name.chars().all(|c| c.is_ascii()) {
                issues.push(format!("Non-ASCII room name: '{}' will use fallback alias", room.name));
            }
        }

        // Check for very long usernames
        for user in &legacy_data.users {
            if user.name.len() > 50 {
                issues.push(format!("Long username: '{}' may need truncation", user.name));
            }
        }

        if issues.is_empty() {
            println!("  ✅ No major issues detected");
        } else {
            for issue in issues {
                println!("  - {}", issue);
            }
        }

        println!("\n✅ Dry run completed successfully!");
        println!("   Run with --migrate to execute the actual migration");

        Ok(())
    }
}